Что происходит в коде?

---

Комментарий пользователя Anonymous #3036451:
Объяснений в комментариях ниже много, однако, на мой взгляд они упускают главное.

При объяснении volatile в лекциях всегда затрагивается вопрос кэша процессора и глобальной памяти:
модификатор volatile, гарантирует, что при обращении к переменной она будет прочитана из памяти.
А если какая-то нить захочет присвоить ей новое значение, то оно обязательно окажется в глобальной памяти.

В классе RethrowableTask метод run() исполняется внутри нити (назовем ее нить1).
Теоретически, нить1 может скопировать себе в кэш поле throwable (если это поле не помечено как volatile),
и, пока нить1 не завершится, в глобальной памяти присвоенное значение (this.throwable = throwable) видно не будет.

В свою очередь, метод rethrow() исполняется в контесте главной нити (запускается из runTaskBySchedule()) и
пытается получить доступ к полю throwable. Если поле throwable  не будет помечено как volatile и нить1 в
этот момент не завершилась, есть вероятность того, что поле throwable будет равно null.

---

Комментарий пользователя Alexey Prilessky:
Алгоритм поиска полей, которые надо пометить как volatile:
1) Вычислить ,сколько в программе будет работать нитей
2) Посмотреть методы run каждой нити
3) В методах run найти поля , общие для всех нитей
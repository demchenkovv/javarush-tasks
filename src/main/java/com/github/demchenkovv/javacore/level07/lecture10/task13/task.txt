Посчитаем
1. Сделай так, чтобы результат успел посчитаться для всех элементов массива values НЕ используя Thread.sleep в методе main(String[] args)
2. Исправь synchronized блок так, чтобы массив values заполнился значением 1


Requirements:
1. Класс Solution должен содержать класс Counter.
2. Класс Counter должен быть нитью.
3. Метод run() класса Counter должен содержать synchronized блок.
4. Synchronized блок метода run() не должен блокировать мьютекс this.
5. Метод main(String[] args) класса Solution не должен использовать Thread.sleep().
6. Для каждой нити, в методе main(String[] args) класса Solution используй метод, который ожидает завершение нити.


// Комментарии к задаче
Метод join() на каком либо потоке использовать обязательно, чтобы гарантировать необходимый вывод.
Ведь какая у нас ситуация:
1) метод мейн создал объекты нитей
2) метод мейн запустил их
3) метод мейн проверяет массив на values[i] != 1
Между 2 и 3 пунктом проходит очень мало времени и работа потоков может не успеть выполниться.
Поэтому join() обязателен, но не понятно зачем в условии прописали вызвать этот метод у всех потоков.
Если 1 поток уже выполнил всю работу, то другие потоки не пройдут по условию цикла (getCount() < 100).
Метод getCount() будет всегда возвращать 100 если хоть 1 поток дошёл до этой отметки.

---
Почему нельзя синхронизироваться по count?
Объекты типа Integer иммутабельны, операция инкремента count++ не меняет состояние объекта по ссылке,
после инкремента переменная count будет ссылаться на другой объект в куче.

Integer count = 0;
...
synchronized (count) {
     incrementCount(); // тут происходит count++;
     ...
}
Что тут происходит:
- Вы захватываете монитор (MonitorEnter) на объекте, доступном по ссылке count.
- Вы инкрементируете значение count, теперь count ссылается на новый Integer.
- В секцию synchronized может зайти другой поток, т.к. по ссылке count объект, на котором еще не произошел MonitorEnter.